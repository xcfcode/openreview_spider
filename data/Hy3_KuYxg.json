{"paper": {"title": "Divide and Conquer with Neural Networks", "authors": ["Alex Nowak", "Joan Bruna"], "authorids": ["anv273@nyu.edu", "bruna@cims.nyu.edu"], "summary": "learn dynamic programming with neural networks", "abstract": "We consider the learning of algorithmic tasks by mere observation of input-output pairs. \nRather than studying this as a black-box discrete regression problem with no assumption whatsoever \non the input-output mapping, we concentrate on tasks that are amenable to the principle of divide and conquer, and study what are its implications in terms of learning. \n\nThis principle creates a powerful inductive bias that we exploit with neural architectures that are defined recursively, by learning two scale-invariant atomic operators: how to split a given input into two disjoint sets, and how to merge two partially solved tasks into a larger partial solution. The scale invariance creates parameter sharing across all stages of the architecture, and the dynamic design creates architectures whose complexity can be tuned in a differentiable manner.\n\nAs a result, our model is trained by backpropagation not only to minimize the errors at the output, but also to do so as efficiently as possible, by enforcing shallower computation graphs. Moreover, thanks to the scale invariance, the model can be trained only with only input/output pairs, removing the need to know oracle intermediate split and merge decisions. As it turns out, accuracy and complexity are not independent qualities, and we verify empirically that when the learnt complexity matches the underlying complexity of the task, this results in higher accuracy and better generalization in two paradigmatic problems: sorting and finding planar convex hulls.", "keywords": ["Deep learning"]}, "meta": {"decision": "Reject", "comment": "The area chair agrees with the reviewers that this paper is not ready for ICLR yet. There are significant issues with the writing, making it difficult to follow the technical details. Writing aside, the technique seems somewhat limited in its applicability. The authors also promised an updated version, but this version was never delivered (latest version is from Nov 13)."}, "review": {"BkkyuCc8e": {"type": "rebuttal", "replyto": "rkKawYqLl", "comment": "Dear reviewer 3,\n\nFirst of all, thanks for the comments and questions, they are really helping us to improve both the paper results and readability.\n\nRegarding your question:  The split architecture for the sorting task, in terms of parameters, it is just a model which is replicated at all nodes of the tree, whose input is a set of normalized points and outputs a binary mask on them. In order to train the model to be able to sort, we define a total loss which is the aggregation of the losses at all nodes.\n\nThe loss at a given node is computed using the output mask probabilities and the mask target we assign at this node. However, these mask targets (which points send to the left and which to the right), are not known 'a priori' (we just have the input-output pair unordered-ordered vector) and we have to find a way to generate them in order to train.\n\nThe procedure to train is the following: with the current model parameters, we split recursively the input until we are left with singletons. Every node of the tree defines a 2-partition on its input set of points. Some of the input points at that node are in the correct place (meaning that if you split recursively optimally from that node, it will nail its correct position in the ordered vector). These are the elements that we can supervise, while the other inputs at that node we won't. So the binary mask is created over these supervised points because we know to which side of the partition these must go in order to end up at the good position.\n\nSo the loss at that node will only take into account the elements that can be supervised, and we won't aggregate gradients from the other points because we are not able to create targets for them. Note that at the beginning of the training, we will only supervise the elements at the largest scale (top node), because most of the deeper partitions will be wrong. However, the supervision at deeper nodes will increase automatically with training as the coarse scales start to produce higher accuracy partitions. \nWe also add a regularization term with the goal of minimizing the whole complexity of the architecture by forcing partitions of same cardinality (maximizing the variance of the output probabilities).\n\nThe important fact of this model is its ability to train just using input-output pairs and adjust complexity. Note that our split block is linear, thus we solve the sorting problem with optimal complexity O(n*log(n)).\n\nWe are currently rewriting the paper to incorporate the reviewer\u2019s feedback and hopefully improve readability. We are also improving our results and have added comparisons with state-of-the-art (which we improve on the sorting), as well as extending the experiments to other tasks to highlight the generic nature of our architecture and training procedure. Since these changes are pretty significant, we understand they may require an extra round of review, but will do our best to update the manuscript before the final decision.\n\nThanks again for taking the time to review our work.", "title": "Answering review 3. Currently improving our results."}, "rkKawYqLl": {"type": "rebuttal", "replyto": "Hy3_KuYxg", "comment": "Dear authors,\n\ndo you plan to address the third reviewer's comments? Your responses could help bring some more clarity and improve the confidence for the final decision...\n\nThanks!", "title": "Author Response to third review?"}, "Hk0l_hNQl": {"type": "rebuttal", "replyto": "BJlYY-X7x", "comment": "Question 1: \u201cThe paper begins with great desiderata, but even after several reads (Sorry for the delay) I still fail to see how much is hardcoded and much supervision the models receive. Am I correct that for sorting  you hardcode the architecture to the the extent that a perfect solution only requires the splitter to split by the first element and the merger to select all elements?\u201d\n\n\nAnswer1: Sorting is a task that illustrates how recursion greatly simplifies the learning on problems that are scale invariant. You are right that the only thing that is needed in a recursive architecture is pivoting -- splitting inputs based on a comparison with some arbitrarily chosen input element. Note however that (i) our model does not hardcode that pivoting step, (ii) whereas an arbitrary pivoting will lead to correct output with average-case complexity O(N log N) , it will have significantly worse constants than the optimal pivoting (given by the median). Our experiments show in that simple setting the advantage of regularizing by the complexity, via the tree balancing.\n\n\n\n\nQuestion 2: \u201cPlease describe in more detail the implementation of the network on the tasks:\n- what is the supervision at each level for each task, maybe provide examples for sorting?\u201d\n\n\nAnswer 1: Our main model does NOT supervise each split/merge level; we only see the correct output at the very end of the split tree (in the example of sorting) and at the very end of the merge tree (in the example of convex hull). \n\n\nWe will provide some clarifying examples for small scales both for split and merge in the appendix.\n\n\n\n\nIn the split case, for instance, consider the input vector [7,1,4,5,6,2,3,8] and its corresponding target [1,2,3,4,5,6,7,8]. We forward the input vector to the recursive architecture. At the first scale obtain the partition (1.1)  ->  [1,4,2] and (1.2) -> [7,5,6,3,8]. The supervision at the first scale is \u2018strong\u2019 because given the cardinality of the output 2-partition (3 + 5 = 8) and the sorted vector we know the corresponding target for this split,  which will be the sets (target 1.1) -> {1,2,3} and (target 1.2) -> {4,5,6,7,8}. The first part of the loss at this scale will be the cross-entropy between the output bernouilli probabilities that the 2-partition has been sampled from p  = [p1, p2, \u2026, p8] and [0,1,0,0,0,1,1,0] which encodes the target. The second part of the loss will be the regularizing term enforcing a balanced partition by penalizing the minus empirical variance of the vector p (i.e, maximizing it).\n\n\nSuppose the partitions at next scale are (2.1) -> [1,2], (2.2) -> [4] and (2.3) -> [7,5,3], (2.4) -> [6,8].\nIn this case, we won\u2019t fully supervise the two splits because of the mistakes done at previous scale. As explained in the paper, we first consider the intersection of the set of elements in each partition with the elements at the same set of coordinates in the target. I.e, \nintersection({1,4,2}, {1,2,3}) = {1,2} and intersection({7,5,6,3,8}, {4,5,6,7,8}) = {5,6,7,8} and this will be the elements that we can supervise for each split. \n\n\nThe First part of the loss of first split will be cross-entropy between [p1, p3] and [0,0] (because the partition was 2 + 1 = 3 but we have only been able to supervise the first two coordinates).\nThe First part of the loss of second split will be the cross-entropy between [p4, p6, p7, p8] and [0,1,0,1] (because the partition was 3 + 2 = 5 but we can only supervise the coordinates 4,6,7,8).\n\n\nThe regularization term for each split will be applied to all bernouilli probabilities, not only the ones we can supervise. Observe that if the split block outputs random 2-partitions, the supervision at smaller scales will be considerably weak. However, the supervision will increase during learning because the splits at large scale will gradually perform correctly.\n\n\n\n\n\n\nQuestion 3: - \u201cfor sorting do you prevent the model from creating overlapping or incomplete partitions (the paper says that you sample, but you can essentially put an element to x1 or x2 depending on a binary variable, or make two tests, one whether the sample is in x1 and another that it is in x2). The first variant simplifies the task a lot.\u201d\n\n\nAnswer 3: Indeed, our initial implementation enforces non-overlapping split. We encode that by producing for each input i to the split block a probability p( i \\in x_1) that said input will be present at x_1. \n\n\nQuestion 4: - \u201cdo you train the basis of the recursion? You train the sorter up to 8 splits, not until sets of 1 element are produced. Do you simply fire quicksort and sort the subsets? Does this mean that if the net provides 8 very unbalanced splits you will feed it with a properly sorted sequence of 256-8 = 246 numbers?\u201d\n\n\nAnswer 4: We will clarify this important point. We keep applying the split module until all the sets are broken down to singletons. \nThe forward pass does NOT sort any subset based on some oracle information. \nThe gradients are only accumulated on the J largest scales (J=8 in our experiments). \nIf the tree for a given input is highly unbalanced (as your example), the loss will disregard any decision taken in the large chunk and promote that (i) the few elements that are split are indeed extrema, and (ii) that split balancing is increased.\n\n\nQuestion 5: - \u201ccan you explain why the weakly supervised convex hull network seems to be better than the strongly supervised one? \u201c\n\n\nAnswer 5: An interesting side-effect of training with weak supervision is that the model is trained under partial errors -- that is each merge block is likely to receive inputs which are not always convex hulls. This is effectively the regime in which the model runs at test time. However, strong supervision learns how to merge of two correct convex hulls into the convex hull of their union, so it has not been trained on inputs which are not convex hulls. This disadvantage could be corrected by \u2018augmenting\u2019 the training in strong supervision, but we emphatically focus on the weak supervision route thanks to its obvious advantages.\n\n\nQuestion 6: - \u201cfor sorting you implement the merger in a way that favors quicksort. Can you compare the performance on partially sorted data (in both directions) which is the true adversarial case for quicksort, rather than test the uniform and exponential distributions, that do not change the expected complexity of quicksort? The trivial solution of splitting on the first element of the set would work optimally under your dataset generation.\u201d\n\n\nAnswer 6: Note that our split model is set-to-set, that is, it is by construction invariant to permutations of the input. This means that the output of the split block does not depend on the the ordering of the input, this is the main reason we haven\u2019t performed these experiments. The feature of the input that can change the complexity of our recursive architecture is its distribution, because the ability to generate correct balanced trees (i.e, estimating the median) can be different depending on the input distribution shape. You can construct another trivial baseline by simply pivoting based on the mean, but for skewed distributions this will be far less efficient than splitting based on the median.", "title": "Answers for Reviewer1"}, "BJlYY-X7x": {"type": "review", "replyto": "Hy3_KuYxg", "review": "The paper begins with great desiderata, but even after several reads (Sorry for the delay) I still fail to see how much is hardcoded and much supervision the models receive. Am I correct that for sorting  you hardcode the architecture to the the extent that a perfect solution only requires the splitter to split by the first element and the merger to select all elements?\n\nPlease describe in more detail the implementation of he network on the tasks:\n- what is the supervision at each level for each task, maybe provide examples for sorting?\n- for sorting do you prevent the model from creating overlapping or incomplete partitions (the paper says that you sample, but you can essentially put an element to x1 or x2 depending on a binary variable, or make two tests, one whether the sample is in x1 and another that it is in x2). The first variant simplifies the task a lot.\n- do you train the basis of the recursion? You train the sorter up to 8 splits, not until sets of 1 element are produced. Do you simply fire quicksort and sort the subsets? Does this mean that if the net provides 8 very unbalanced splits you will feed it with a properly sorted sequence of 256-8 = 246 numbers?\n- can you explain why the weakly supervised convex hull network seems to be better than the strongly supervised one? \n- for sorting you implement the merger in a way that favors quicksort. Can you compare the performance on partially sorted data (in both directions) which is the true adversarial case for quicksort, rather than test the uniform and exponential distributions, that do not change the expected complexity of quicksort? The trivial solution of splitting on the first element of the set would work optimally under your dataset generation.\n\n\nThe basic idea of this contribution is very nice and worth pursuing: how to use the powerful \u201cdivide and conquer\u201d algorithm design strategy to learn better programs for tasks such as sorting or planar convex hull. However, the execution of this idea is not convincing and needs polishing before acceptance. As it is right now, the paper has a proof-of-concept feel that makes it great for a workshop contribution.\n\nMy main concern is that the method presented is currently not easily applicable to other tasks. Typically, demonstrations of program induction from input-output examples on well known tasks serves the purpose of proving, that a generic learning machine is able to solve some well known tasks, and will be useful on other tasks due to its generality. This contribution, however, presents a learning machine that is very hand-tailored to the two chosen tasks. The paper essentially demonstrates that with enough engineering (hardcoding the recurrency structure, designing problem-specific rules of supervision at lower recurrency levels) one can get a partially trainable sorter or convex hull solver.\n\nI found the contribution relatively hard to understand. High level ideas are mixed with low-level tricks required to get the model to work and it is not clear either how the models operate, nor how much of them was actually learned, and how much was designed. The answer to the questions did hep, nut didn't make it into the paper. Mixing the descriptions of the tricks required to solve the two tasks makes things even more confusing. I believe that the paper would be much more accessible if instead of promising a general solution it clearly stated the challenges faced by the authors and the possible solutions.\n\nHighlights:\n+ Proof-of-concept of a partially-trainable implementation of the important \u201cdivide and conquer\u201d paradigm\n++ Explicit reasoning about complexity of induced programs\n- The solution isn\u2019t generic enough to be applicable to unknown problems - the networks require tricks specific to each problem\n- The writing style pictures the method as very general, but falls back on very low level details specific to each task\n", "title": "Please clearly state what parts of the models are trained", "rating": "4: Ok but not good enough - rejection", "confidence": "4: The reviewer is confident but not absolutely certain that the evaluation is correct"}, "B1slAdMEe": {"type": "review", "replyto": "Hy3_KuYxg", "review": "The paper begins with great desiderata, but even after several reads (Sorry for the delay) I still fail to see how much is hardcoded and much supervision the models receive. Am I correct that for sorting  you hardcode the architecture to the the extent that a perfect solution only requires the splitter to split by the first element and the merger to select all elements?\n\nPlease describe in more detail the implementation of he network on the tasks:\n- what is the supervision at each level for each task, maybe provide examples for sorting?\n- for sorting do you prevent the model from creating overlapping or incomplete partitions (the paper says that you sample, but you can essentially put an element to x1 or x2 depending on a binary variable, or make two tests, one whether the sample is in x1 and another that it is in x2). The first variant simplifies the task a lot.\n- do you train the basis of the recursion? You train the sorter up to 8 splits, not until sets of 1 element are produced. Do you simply fire quicksort and sort the subsets? Does this mean that if the net provides 8 very unbalanced splits you will feed it with a properly sorted sequence of 256-8 = 246 numbers?\n- can you explain why the weakly supervised convex hull network seems to be better than the strongly supervised one? \n- for sorting you implement the merger in a way that favors quicksort. Can you compare the performance on partially sorted data (in both directions) which is the true adversarial case for quicksort, rather than test the uniform and exponential distributions, that do not change the expected complexity of quicksort? The trivial solution of splitting on the first element of the set would work optimally under your dataset generation.\n\n\nThe basic idea of this contribution is very nice and worth pursuing: how to use the powerful \u201cdivide and conquer\u201d algorithm design strategy to learn better programs for tasks such as sorting or planar convex hull. However, the execution of this idea is not convincing and needs polishing before acceptance. As it is right now, the paper has a proof-of-concept feel that makes it great for a workshop contribution.\n\nMy main concern is that the method presented is currently not easily applicable to other tasks. Typically, demonstrations of program induction from input-output examples on well known tasks serves the purpose of proving, that a generic learning machine is able to solve some well known tasks, and will be useful on other tasks due to its generality. This contribution, however, presents a learning machine that is very hand-tailored to the two chosen tasks. The paper essentially demonstrates that with enough engineering (hardcoding the recurrency structure, designing problem-specific rules of supervision at lower recurrency levels) one can get a partially trainable sorter or convex hull solver.\n\nI found the contribution relatively hard to understand. High level ideas are mixed with low-level tricks required to get the model to work and it is not clear either how the models operate, nor how much of them was actually learned, and how much was designed. The answer to the questions did hep, nut didn't make it into the paper. Mixing the descriptions of the tricks required to solve the two tasks makes things even more confusing. I believe that the paper would be much more accessible if instead of promising a general solution it clearly stated the challenges faced by the authors and the possible solutions.\n\nHighlights:\n+ Proof-of-concept of a partially-trainable implementation of the important \u201cdivide and conquer\u201d paradigm\n++ Explicit reasoning about complexity of induced programs\n- The solution isn\u2019t generic enough to be applicable to unknown problems - the networks require tricks specific to each problem\n- The writing style pictures the method as very general, but falls back on very low level details specific to each task\n", "title": "Please clearly state what parts of the models are trained", "rating": "4: Ok but not good enough - rejection", "confidence": "4: The reviewer is confident but not absolutely certain that the evaluation is correct"}, "BJzCfAJ7g": {"type": "review", "replyto": "Hy3_KuYxg", "review": "How do you backpropagate through the sampling procedures? Are the gradient estimates biased?\nI find this paper extremely hard to read. The main promise of the paper is to train models for combinatorial search procedures, especially for dynamic programming to learn where to split and merge. The present methodology is supposed to make use of some form of scale invariance property which is scarcely motivated for most problems this approach should be relevant for. However, the general research direction is fruitful and important.\n\nThe paper would be much more readable if it would start with a clear, formal problem formulation, followed by some schematic view on the overall flow and description on which parts are supervised, which parts are not. Also a tabular form and sample of the various kinds problems solved by this method could be listed in the beginning as a motivation with some clear description on how they fit the central paradigm and motivate the rest of the paper in a more concrete manner.\n\nInstead, the paper is quite chaotic, switching between low-level and high level details, problem formulations and their solutions in a somewhat random, hard to parse order.\n\nBoth split and merge phases seem to make a lot of discrete choices in a hierarchical manner during training. The paper does not explain how those discrete choices are backpropagated through the network in an unbiased manner, if that is the case at all.\n\nIn general, the direction this paper is exciting, but the paper itself is a frustrating read in its present form. I have spent several hours on it without having to manage to achieve a clear mental image on how all the presented pieces fit together. I would revise my score if the paper would be improved greatly from a readability perspective, but I think it would require a major rewrite.", "title": "Backpropagation through the sampling operation", "rating": "3: Clear rejection", "confidence": "2: The reviewer is willing to defend the evaluation, but it is quite likely that the reviewer did not understand central parts of the paper"}, "ryHF2_JEx": {"type": "review", "replyto": "Hy3_KuYxg", "review": "How do you backpropagate through the sampling procedures? Are the gradient estimates biased?\nI find this paper extremely hard to read. The main promise of the paper is to train models for combinatorial search procedures, especially for dynamic programming to learn where to split and merge. The present methodology is supposed to make use of some form of scale invariance property which is scarcely motivated for most problems this approach should be relevant for. However, the general research direction is fruitful and important.\n\nThe paper would be much more readable if it would start with a clear, formal problem formulation, followed by some schematic view on the overall flow and description on which parts are supervised, which parts are not. Also a tabular form and sample of the various kinds problems solved by this method could be listed in the beginning as a motivation with some clear description on how they fit the central paradigm and motivate the rest of the paper in a more concrete manner.\n\nInstead, the paper is quite chaotic, switching between low-level and high level details, problem formulations and their solutions in a somewhat random, hard to parse order.\n\nBoth split and merge phases seem to make a lot of discrete choices in a hierarchical manner during training. The paper does not explain how those discrete choices are backpropagated through the network in an unbiased manner, if that is the case at all.\n\nIn general, the direction this paper is exciting, but the paper itself is a frustrating read in its present form. I have spent several hours on it without having to manage to achieve a clear mental image on how all the presented pieces fit together. I would revise my score if the paper would be improved greatly from a readability perspective, but I think it would require a major rewrite.", "title": "Backpropagation through the sampling operation", "rating": "3: Clear rejection", "confidence": "2: The reviewer is willing to defend the evaluation, but it is quite likely that the reviewer did not understand central parts of the paper"}, "HJubZpAel": {"type": "rebuttal", "replyto": "Bk2vxpClg", "comment": "yes pls upload a revised pdf", "title": "pdf upload"}, "Bk2vxpClg": {"type": "rebuttal", "replyto": "ByQnnICge", "comment": "Dear PC,\nWe have updated the main pdf file (sorry it was a spurious package lurking). \n\nShould I create a revision?", "title": "Fixed"}, "ByQnnICge": {"type": "rebuttal", "replyto": "Hy3_KuYxg", "comment": "Dear Authors,\n\nPlease resubmit your paper in the ICLR 2017 format with the correct margin spacing for your submission to be considered. Thank you!", "title": "ICLR Paper Format"}}}