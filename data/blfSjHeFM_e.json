{"paper": {"title": "MALI: A memory efficient and reverse accurate integrator for Neural ODEs", "authors": ["Juntang Zhuang", "Nicha C Dvornek", "sekhar tatikonda", "James s Duncan"], "authorids": ["~Juntang_Zhuang1", "~Nicha_C_Dvornek1", "~sekhar_tatikonda1", "~James_s_Duncan1"], "summary": "A solver for ODE that guarantees accuracy in reverse-time trajectory  at a constant memory cost", "abstract": "Neural ordinary differential equations (Neural ODEs) are a new family of deep-learning models with continuous depth. However, the numerical estimation of the gradient in the continuous case is not well solved: existing implementations of the adjoint method suffer from inaccuracy in reverse-time trajectory, while the naive method and the adaptive checkpoint adjoint method (ACA) have a memory cost that grows with integration time. In this project, based on the asynchronous leapfrog (ALF) solver, we propose the Memory-efficient ALF Integrator (MALI), which has a constant memory cost $w.r.t$ integration time similar to the adjoint method, and guarantees accuracy in reverse-time trajectory (hence accuracy in gradient estimation). We validate MALI in various tasks: on image recognition tasks, to our knowledge, MALI is the first to enable feasible training of a Neural ODE on ImageNet and outperform a well-tuned ResNet, while existing methods fail due to either heavy memory burden or inaccuracy; for time series modeling, MALI significantly outperforms the adjoint method; and for continuous generative models, MALI achieves new state-of-the-art performance. We provide a pypi package: https://jzkay12.github.io/TorchDiffEqPack", "keywords": ["neural ode", "memory efficient", "reverse accuracy", "gradient estimation"]}, "meta": {"decision": "Accept (Poster)", "comment": "This paper introduced a new ODE integration scheme that allows constant-memory gradient computation.  I was concerned that the low order of convergence of this method would make it impractical, but the authors performed extensive experiments and got impressive results.  Overall the paper addresses one of the main practical difficulties with large neural ODE models.  The authors satisfactorily addressed the reviewers' concerns in the discussion."}, "review": {"vRzsaXWM_wr": {"type": "rebuttal", "replyto": "0YoCSo2VB09", "comment": "Thanks a lot. It might be due to the same abbreviation is used in latex reference. We will fix this in the final version.", "title": "Thanks for pointing out, will fix the reference"}, "_18slxWUvVY": {"type": "rebuttal", "replyto": "grudCZaJxP", "comment": "Thanks for the insightful review for our submission and author response. \n* We have updated the paragraph as suggested. \n*For the experiment of different solvers, it's likely that Dopri5 achieves a lower accuracy because the error tolerance is too large (rtol=1e-2). We conducted another experiment with Dopri5 using rtol=1e-5 and achieved a better test accuracy of 70.07 on ImageNet. Though still slightly worse than the best of RK4, it demonstrates the trend that as error tolerance of adaptive ODE solver decreases, the accuracy increases. \n\nThanks for the review. Please let us know if you have any further questions.", "title": "Thanks for your review"}, "EtToZWmr-Vd": {"type": "review", "replyto": "blfSjHeFM_e", "review": "Summary: This paper presents a memory-efficient asynchronous leapfrog integrator for numerically solving neural ODEs, referred to as MALI. The method comes with a constant memory guarantee (like the adjoint method) and also guarantees reverse-time accuracy (like the adaptive checkpoint adjoint (ACA) method). The authors also give a rigorous theoretical analysis of MALI, and also discuss a \"damped\" version with an increased stability region. The method is evaluated on a variety of tasks which includes classification, dynamical modelling and generative modelling.\n\nPros:\n- The theoretical analysis looks correct, noting that I haven't worked out all the details.\n- Experimental evaluation is very exhaustive, and MALI achieves near-the-best performance in all tasks.\n- The method is proven as accurate as the standard numerical ODE solvers. Thanks to its reduced memory cost (compared to ACA), MALI can then be treated as an off-the-shelf replacement.\n\nCons and Questions:\n- Looking at the results, I'm having difficulty seeing any significant improvement upon ACA. Then the main contribution (in addition to the theoretical analysis) is the reduced memory consumption, which makes me rethink whether ICLR is a suitable venue.\n- Although the memory costs of the adjoint method and MALI are $O(N_f)$ and $O(N_f+1)$, this doesn't really reflect in Figure 4c, where the blue bar doubles the red one. I'd be happy if the authors can briefly explain why\n- Looking at Table-2, why does the test performance of a NODE trained with MALI increase when we switch from MALI to RK4? It would be much nicer to see some error variance estimate.\n- I would be happy to see an experimental evaluation of the \"A-stability\". As mentioned by the authors, the stability analysis is asymptotic and T could be arbitrarily small in, e.g., continuous-time flows. However, that's not the case in time-series modelling. So I wonder if the stability claim can be verified on a scenario in which, e.g., 100 observations arrive uniformly in time with 10 secs gaps.\n- To generate Table-2, did you train a ResNet without any differentials/integrals involved and try to evaluate the test performance using an ODE solver (simply using the trained ResNet as the drift function)? If so, I don't think this makes any sense except Euler-1 solver, and the entire ResNet row in Table-2 could go away.\n\nAdditional comments:\n- Figure-4 caption could include some more detail (at least mentioning the experiment name) \n- Why is there a \"local forward\" step within the for loop in the backward routine in Alg.4?\n- It would be nice to see a brief description of the mujoco dataset.\n- Typo in the title of section B.3.2.\n\nNote: After rebuttal, I increase my overall score from 6 to 7.", "title": "A good submission & a few questions", "rating": "7: Good paper, accept", "confidence": "3: The reviewer is fairly confident that the evaluation is correct"}, "U5tuSzBdhCq": {"type": "rebuttal", "replyto": "egwVS86gpUz", "comment": "Thanks for reviewing our paper and author response, please let us know if you have any further questions.", "title": "Thanks for your review"}, "2tYCvPDe7Cm": {"type": "review", "replyto": "blfSjHeFM_e", "review": "**Paper summary**\nThere are typically two methods for estimating the gradients with respect to the loss for neural ODEs. The naive method directly backpropagates through the steps of the ODE solver leading to accurate gradients but very large memory cost. The adjoint method in contrast does not store the entire trajectory in memory, but has reverse trajectory errors (i.e. the numerical solution in the reverse direction will not be the inverse of the numerical solution in the forward direction). In this paper, the authors propose a method that is both reverse accurate and has low memory cost.\n\nTo achieve this the authors take advantage of the asynchronous leapfrog solver. This numerical method is reversible: solving an ODE numerically in the reverse direction is the inverse of solving the ODE numerically in the forward direction. This is not generally true for the ODE solvers typically used (RK4 and so on) in the neural ODE literature. As the numerical solver is explicitly invertible, the authors can (from only the final state and not the entire trajectory) locally reconstruct each ODE solver step to get the local gradient of the parameters with respect to the loss. They can then calculate these gradients along the entire reverse trajectory to obtain an accurate estimate of the gradient with respect to the parameters. As each step of the numerical solver is reversible, they do not need to store the entire trajectory. The authors analyse the stability and numerical error of their proposed method and provide a toy example to show how well their method estimates gradients compared the naive, adjoint and adaptive checkpoint methods.\n\nThe authors then perform experiments on a variety of tasks to test their model. They test their model on image classification experiments, both on CIFAR10 and Imagenet and achieve good results compared to the baselines. In addition, they perform adversarial robustness experiments on ImageNet and also show good performance. Finally, the authors test their method both for time series modeling and continuous normalizing flows, again showing good performance compared with naive integration methods.\n\n**Positives**\n- The motivation and core idea of the paper is clear. Numerical solvers are in general not reversible and this can lead to inaccurate gradient estimates when using the adjoint method. The authors explain this clearly and then propose a method that effectively solves this.\n- The experimental results are quite impressive. The model performs on par with the adaptive checkpoint method in terms of accuracy but is much more memory efficient (and notably memory is independent of the number of integration steps). This allows the authors to run their model on large scale datasets like ImageNet which was not previously possible with most neural ODE methods. Further, the authors achieve good performance on quite a wide variety of tasks (image classification, adversarial attacks, time series modeling, generative modeling) which is nice.\n- The authors perform a thorough analysis of the runtime of their integration method compared to others which is very helpful.\n\n**Negatives**\n- The presentation of the method and results is not always very clear. For example, the section about damping for the ALF integrator is not clear. The authors mention that ALF is not stable for eta=1, but (as far as I can tell) never mention what value of eta they use in practice and whether choosing this value is difficult. Further, it is not clear if ALF is still reversible with this eta parameter. Presumably you would have to use 1/eta in the reverse step for it to remain invertible, in which case the reverse is not stable? The authors should be more clear about this.\n- The toy example is confusing. How come the integration time starts from t=20? Is this because the error only grows after t=20? As you use T=1 for all experiments (and the rtol and atol are also roughly the same for all experiments), it would be nice to see if this actually makes a difference also for t<1. In Figure 4, the authors also mention the derivative dL/dy_0 but this derivative is never mentioned in the text. Do you mean dL/dz_0? The plots of memory consumption are nice and clear though.\n- The ALF solver already exists, so the main contribution of the paper is simply to apply the ALF solver to neural ODEs. This means that the novelty of the method is somewhat limited, but I do not think that this is a major issue as the method works well and is clearly motivated.\n- The section about using different numerical solvers for ResNets does not make much sense. ResNets are not designed as flows and do not behave as flows in practice, so we should not expect them to work at all with other numerical solvers than Euler with timestep=1. I don\u2019t really think these experiments show anything interesting and should be removed for clarity.\n\n**Recommendation**\nOverall the paper has a clear motivation, provides a nice and simple solution to an interesting problem and has good experimental results. However, there are some clarity issues which make some aspects of the model and method confusing. I therefore recommend a weak accept but would increase my score if the clarity issues are solved.\n\n**Questions**\nThe model achieves extremely good bits/dim on MNIST (0.87). However, it seems from the appendix that the samples are fairly poor (compared to vanilla FFJORD for example). Log likelihood and sample quality are not always correlated, but the difference seems particularly jarring here. Do you know why this is?\n\n**Typos and small comments**\n- In many places the authors use latex math to write words that should either just be written in italics (w.r.t) or using \\text{} in math mode (e.g. atol, rtol).\n- There are several typos in the script, so I think it would be a good idea for the authors to read through the script again to fix those.\n- In several places, the authors write O(N_f + 1) which instead should be O(N_f)\n- The authors often write \u201cconstant memory cost with respect to integration time\u201d. I think it would be more helpful to say \u201cnumber of solver steps\u201d or something along those lines as integration time typically refers to the upper limit of the integral when solving an ODE.\n", "title": "Simple method with convincing experimental results, although there are some clarity issues", "rating": "7: Good paper, accept", "confidence": "4: The reviewer is confident but not absolutely certain that the evaluation is correct"}, "YF6cDFKQvLR": {"type": "rebuttal", "replyto": "EtToZWmr-Vd", "comment": "Thanks for the insightful comments, and we address your concerns below.\n\n**Con 1: Looking at the results, I'm having difficulty seeing any significant improvement upon ACA.**\n\nThe biggest advantage of MALI over ACA is in the constant memory cost, hence is suitable for high-dimensional problems. The memory issue is critical in practice; note ACA cannot run on continuous normalizing flow even on Cifar10 because of its large memory, and ACA cannot deal with large datasets like ImageNet.\n\n**Con 2: this doesn't really reflect in Figure 4c, where the blue bar doubles the red one. I'd be happy if the authors can briefly explain why**\n\nWe have updated table 1 and remove the big $O$ notation. Using $N_z$ to denote the dimension of hidden state $z$, the memory for adjoint is $N_z N_f$, while is $N_z (N_f+1)$ for MALI. \n\nNote that $N_f$ is not a large number, in Fig 4(c) we use a two-layer network in $f$, hence $N_f$=2 and $N_f+1=3$, and the ratio $(N_f+1)/N_f$ is 1.5.\n\nFurthermore, we record the peak memory usage, note that in Algorithm 2, there are extra variables $k_1$ and $u_1$, they also count toward the \u201cpeak memory\u201d usage, and they are deleted after the entire execution of Algo 2 (rather than immediately deleted after usage) in coding, hence this contributes to the \u201cpeak memory\u201d. However, the code can be easily modified to delete them right away after usage in order to keep a low peak memory usage.\n\n**Con 3: why does the test performance of a NODE trained with MALI increase when we switch from MALI to RK4?**\n\nThe increase in test accuracy perhaps is because our method is actually learning a continuous model, hence is invariant to different numerical ODE solvers. Note that RK4 is typically more accurate than MALI: for a stepsize h, the local error of RK4 is of order $O(h^4)$, while is $O(h^3)$ for MALI, hence RK4 is perhaps more accurate in terms of numerically approximating an ODE.\n\nDue to limited computation resource, we were not able to perform several experiments on ImageNet to obtain variance estimates. We conducted 5 independent experiments on CIFAR10, and Fig. 5 shows some variance estimates for the accuracy of different methods.\n\n**Con 4: I would be happy to see an experimental evaluation of the \"A-stability\".**\n\nFor all experiments in current submission, we set $\\eta=1$. We conducted extra experiments with $\\eta<1$, and MALI is robust to different choices of $\\eta$. Note that the latent-ODE experiment is performed on the Mujoco dataset, with each time series has about 100 observation time points.  Link to results: https://openreview.net/forum?id=blfSjHeFM_e&noteId=hmWwoXnCaN\n\n**Con 5: To generate Table-2, did you train a ResNet without any differentials/integrals involved and try to evaluate the test performance using an ODE solver**\n\nThe ResNet is trained without considering integration, and we have removed this part in revision as suggested.\nAs stated in Sec4.2 \u201cInvariance to discretization scheme\u201d, we agree with the reviewer and think that \u201cResNet as a one-step Euler discretization fails to be a meaningful dynamical system\u201d. However, many papers perform theoretical analysis of ResNet as an approximation to ODE. In order to test this hypothesis, we summarize results for ResNet with different ODE solvers, and mark the result for one-step Euler solver in bold font to emphasize the best result of ResNet.\n\n**Additional comment 1: Caption of Fig.4**\nThanks for pointing out, we have updated in the revision.\n\n**Additional comment 2: Why is there a \"local forward\" step within the for loop in the backward routine in Alg.4?**\n\nThe computation graph associated with \u201clocal forward\u201d is deleted during forward-time integration to save memory. Hence in the backward pass, we need to reconstruct the local forward to calculate the gradient. The same is required for the adjoint method in the \u201ctorchdiffeq\u201d package accompanying [1]; see local forward: https://github.com/rtqichen/torchdiffeq/blob/5dbaf8585ff9e601889811b7a5859ccf87dc576a/torchdiffeq/_impl/adjoint.py#L98, \nlocal backward: https://github.com/rtqichen/torchdiffeq/blob/5dbaf8585ff9e601889811b7a5859ccf87dc576a/torchdiffeq/_impl/adjoint.py#L105.\n\n**Additional comment 3: It would be nice to see a brief description of the mujoco dataset.**\n\nWe have added description and reference as suggested.\n\n**Additional comment 4: Typo in the title of section B.3.2.**\n\nThanks for pointing out, we fixed it in revision.\n\n\n\n\n\n\n\n\n", "title": "Response to reviewer 2"}, "oB6UYYdZOAR": {"type": "rebuttal", "replyto": "MsiMz9fV1d", "comment": "Thanks for the constructive review. We address your concerns below.\n\n**Concern 1: it would be nice to see if the empirical improvements hold up for $\\eta<1$, where stable regions do exist**\n\nFor all experiments in current submission, we set $\\eta=1$. We conducted extra experiments with $\\eta<1$, and MALI is robust to different choices of $\\eta$. https://openreview.net/forum?id=blfSjHeFM_e&noteId=hmWwoXnCaN\n\n**Concern 2: The naive method seems too naive. Why are all results from all evaluations being saved?**\n\nThe \u201cnaive\u201d integration is from the \u201ctorchdiffeq\u201d package accompanying [1]; it does not discard unused steps to search for optimal stepsize.\nThis can be found at https://github.com/rtqichen/torchdiffeq/blob/5dbaf8585ff9e601889811b7a5859ccf87dc576a/torchdiffeq/_impl/misc.py#L95, where the variable \u201cerror_ratio\u201d is  calculated from the current step and is used to estimate the next stepsize. This function is called recursively until an acceptable stepsize is found. Note that \u201cerror_ratio\u201d is not detached from the computation graph, hence the extra $m-1$ step is back-propagated in the \u201codeint\u201d method: https://github.com/rtqichen/torchdiffeq/blob/5dbaf8585ff9e601889811b7a5859ccf87dc576a/torchdiffeq/_impl/odeint.py#L27. (Note \u201codeint\u201d is not \u201codeint_adjoint\u201d)\n\nACA proposed to discard the additional $m-1$ steps [2], and ACA typically achieves better accuracy than the adjoint.\n\n**Other comments 1-3: Fix typos**\n\nThanks for pointing out the typos in 1-3 of \"other comments\", we have updated in the revision.\n\n**Other comments 4: In various locations, notation like $O(N+1)$is used. Should this just be $O(N)$ since I assume is $N$ at least $\\Omega(1)$?**\n\nWe originally use $O(N_f+1)$ in order to emphasize the increased memory cost for MALI compared with the adjoint method. Also note that $N_f$ is typically less than 10 for one ODE block.\nWe update the table to reflect actual costs, removing the big $O$ notations and multiplying the memory and computation cost by $N_z$, which is the dimension of the hidden state.\n\n**Other comments 5: It seems a bit strange that we have to do a local forward and local backward pass in Algorithm 4**\n\nThe local forward and backward evaluation is necessary to evaluate $\\frac{\\partial f}{\\partial z}$ and $\\frac{\\partial f}{\\partial \\theta}$, because it's deleted in the forward-time integration to save memory. It is also necessary for the \u201cadjoint\u201d method in the \u201ctorchdiffeq\u201d package.\nLocal forward: https://github.com/rtqichen/torchdiffeq/blob/5dbaf8585ff9e601889811b7a5859ccf87dc576a/torchdiffeq/_impl/adjoint.py#L98,\nlocal backward:  https://github.com/rtqichen/torchdiffeq/blob/5dbaf8585ff9e601889811b7a5859ccf87dc576a/torchdiffeq/_impl/adjoint.py#L105\n\n**Other comments 5: Could this be solved by making each layer of $f$ invertible?**\n\nFor general form of $f$ and general ODE solvers (such as the Runge-Kutta method), to our knowledge no existing methods can guarantee invertibility and accurately reconstruct the forward-time trajectory only from the end-time state.\nTo our knowledge, MALI (ALF) is the first method to achieve invertibility for general form of $f$.\nIt\u2019s possible to use some special invertible structures in $f$, so every evaluation of $f$ is invertible regardless of the ODE solver; however, such structures might be unsuitable for many practical problems. For example, in some biological and physical ODE models, $f$ takes a linear form and  the numerical integration is typically not strictly explicitly invertible. Though there are implicit methods, it typically requires iteration for each step and is not suitable for high-dimensional cases.\n\n[1] Chen, Ricky TQ, et al. \"Neural ordinary differential equations.\" Advances in neural information processing systems. 2018.\n\n[2] Zhuang, Juntang, et al. \"Adaptive Checkpoint Adjoint Method for Gradient Estimation in Neural ODE.\" arXiv preprint arXiv:2006.02493 (2020).\n\n\n", "title": "Response to reviewer 4"}, "PleTzx8oHeN": {"type": "rebuttal", "replyto": "2tYCvPDe7Cm", "comment": "Thanks for the insightful comments, we address your concerns below.\n\n**Negative 1: the section about damping for the ALF integrator is not clear.**\n\nThanks for pointing out. For all experiments in current submission, $\\eta$ is set as 1. We conducted experiments with $\\eta<1$, and found that MALI is typically robust to different $\\eta$ values. Link to results: https://openreview.net/forum?id=blfSjHeFM_e&noteId=hmWwoXnCaN\n\nWith $\\eta<1$, Damped ALF is still invertible, we have updated the inverse of damped ALF in Appendix A.5. \nTo consider the stability of inverse of ALF, we need to calculate the eigenvalue of the Jacobian. Note that the Jacobian of inverse ALF is the inverse of the Jacobian for forward ALF. Also note that the eigenvalue of the inverse of a matrix is the inverse of its eigenvalue, if the eigenvalue is not 0. Therefore, stability of inverse ALF requires Eq.34 in Appendix to have a norm larger than 1, and the stability region is non-empty.\n\n**Negative 2: it would be nice to see if this actually makes a difference also for t<1**\n\nThanks for pointing out, we use T=20 mainly for the purpose for visualization. We added an example when T<1 in Fig.6 of the appendix; MALI achieves comparable error as ACA, and both outperform the na\u00efve and adjoint method.\nFig. 4 caption has a typo, it should be dL/dz_0; we have updated it in the revision.\n\n**Negative 4: The section about using different numerical solvers for ResNets does not make much sense.**\n\nWe have removed this part in the revision as suggested by the reviewer. As stated in Sec4.2 \u201cInvariance to discretization scheme\u201d, we agree with the reviewer and think that \u201cResNet as a one-step Euler discretization fails to be a meaningful dynamical system\u201d. However, as stated in [1], \u201cresidual units are interpreted as one step of a forward Euler method for the numerical integration of a parameterized ordinary differential equation (ODE)\u201d[2,3]. In order to test this hypothesis in the original submission, we summarize results for ResNet with different ODE solvers.\n\n**Question: Results of FFJORD on MNIST**\n\nWe apologize that we used the wrong figure for generated examples for the MNIST dataset. The figures for MNIST were generated using a low temperature (~0.7). We have revised the paper to use examples generated with temperature=1.0. With a low temperature, the hidden state is close to 0 and the model tends to generate similar figures (visually the figures under low temperature are more blurry). \n\nWe are not aware of the exact reason for the mismatch between sample quality and log probability. But we found reference [4] stated that \u201cIn particular, we show that three of the currently most commonly used criteria\u2014average log-likelihood, Parzen window estimates, and visual fidelity of samples\u2014are largely independent of each other when the data is high-dimensional.\u201d\n\n**Typos and other comments**\nWe have fixed typos as suggested, and replaced the big O notation with the actual cost (note that $N_f$ is not large in practice), and modified the description of constant memory.\n\n[1] Queiruga, Alejandro F., et al. \"Continuous-in-Depth Neural Networks.\" arXiv preprint arXiv:2008.02389 (2020).\n\n[2] Eldad Haber and Lars Ruthotto. Stable architectures for deep neural networks.Inverse Problems, 34(1):014004,2017.\n\n[3] Eldad Haber, Keegan Lensink, Eran Treister, and Lars Ruthotto. IMEXnet: A forward stable deep neural network.InInternational Conference on Machine Learning, pages 2525\u20132534, 2019.\n\n[4] Lucas Theis, A\u00e4ron van den Oord, and Matthias Bethge. A note on the evaluation of generative models. arXiv preprint arXiv:1511.01844, 2015.", "title": "Response to reviewer 1"}, "ZHL7J29qYrM": {"type": "rebuttal", "replyto": "E6TmZHTdAEz", "comment": "Thanks for the nice review, we address your concerns below.\n\n**Concern 1: The concept of Neural ODE models, their scope and their expected usefulness should be better motivated.**\n\nThanks for pointing out. The motivation for Neural ODE is briefly discussed in the introduction, but not explained in detail due to the limited paper length. We summarize a few motivations here.\n\nConventional RNNs typically require the data to be sampled in an even grid, so that the time step between two consecutive observations is a constant. However, in real-world applications, such as tracking the record of a patient, the data is often irregularly sampled. A continuous ODE model can be evaluated at arbitrary time points, hence is suitable for this case [3].\n\nMuch knowledge about physics and biology are in the form of differential equations. Hence it\u2019s natural to incorporate such knowledge into a Neural ODE model, such as the Hamiltonian system [1] or three-body system [2].\n\nNeural ODEs can also be used for generative modeling. Discrete-layer normalizing flows typically have special structures to guarantee invertibility, while continuous ODE models are naturally invertible (in theory) hence is suitable for free-form generative models [4].\n\n**Concern 2: The integrations scheme seems already known and well established.**\n\nThe method of ALF is published on 2011 [5], however it\u2019s a pity that it\u2019s never cited or noticed. We found it to be perfectly suitable for the high-dimensional Neural ODE models.\n\n**Concern 3: It does not seem that the paper makes code and data available to the public.**\n\nSorry we were not able to polish the code before submission, we provide link to our code https://www.dropbox.com/s/8tu0lck9ftpve4n/code_for_MALI.zip?dl=0\n\n**Remark a):It seems that the stepsize h should be initialized upon every step. Otherwise the steps can only get smaller**\n\nThanks for pointing out. We found some typo in Algo 1. If the error estimate is below tolerance, then the stepsize is increased by a certain factor; if the error estimate is above tolerance, then stepsize is decreased. We updated this in the revision.\n\n**Remark b): References: capitalization not correct**  Thanks for pointing out, we have fixed these in the revision.\n\n**Remark c): What benefits does the neural ODE model have in the context of image classification**\n\nFor image classification, the biggest advantage of Neural ODE model is their robustness to adversarial attacks. This is extensively studied in [6]. The intuition is ODE models with bounded norm on the gradient (this is often satisfied in Neural ODE since the weights can only take finite real values in popular frameworks such as PyTorch and Tensorflow) defines a bijection between the initial state and the end-time state. In other words, the integral curves are non-intersecting [6]. In contrast for discrete models such as ResNet, the curves can easily intersect, hence small perturbations in the input can cause very different output.\n\n[1] Desmond Zhong, Yaofeng, Biswadip Dey, and Amit Chakraborty. \"Symplectic ODE-Net: Learning Hamiltonian Dynamics with Control.\" arXiv (2019): arXiv-1909.\n\n[2] Zhuang, Juntang, et al. \"Adaptive Checkpoint Adjoint Method for Gradient Estimation in Neural ODE.\" arXiv preprint arXiv:2006.02493 (2020).\n\n[3] Rubanova, Yulia, Ricky TQ Chen, and David Duvenaud. \"Latent odes for irregularly-sampled time series.\" arXiv preprint arXiv:1907.03907 (2019).\n\n[4] Grathwohl, Will, et al. \"Ffjord: Free-form continuous dynamics for scalable reversible generative models.\" arXiv preprint arXiv:1810.01367 (2018).\n\n[5] Mutze, Ulrich. \"An asynchronous leapfrog method II.\" arXiv preprint arXiv:1311.6602 (2011).\n\n[6] Hanshu, Y. A. N., et al. \"On robustness of neural ordinary differential equations.\" International Conference on Learning Representations. 2019.\n", "title": "Response to reviewer 3"}, "hmWwoXnCaN": {"type": "rebuttal", "replyto": "blfSjHeFM_e", "comment": "All results in the submission are generated using $\\eta=1$. We have updated the results for $\\eta<1$ as suggested by reviewers. MALI demonstrate robustness to different $\\eta$ values.\n\n|                        $ \\eta $                               |                         |        1.0         |     0.95    |     0.9     |     0.85     |\n|:---------------------------------------------------:|:-----------------:|:-----------:|:-----------:|:-----------:|:------------:|\n| Test Accuracy on Speech Commands (Higher is better) |                   | $93.7\\pm0.3$ | $93.7\\pm0.1$ | $93.5\\pm0.2$ | $93.7\\pm0.3$ |\n| Test MSE of latent ODE  on Mujoco (Lower is better) | 10% training data |     0.35    |     0.36    |     0.33    |     0.33     |\n|                            Test MSE of latent ODE  on Mujoco (Lower is better)                          | 20% training data |     0.27    |     0.25    |     0.26    |     0.27     |", "title": "Updated results for $\\eta<1$"}, "E6TmZHTdAEz": {"type": "review", "replyto": "blfSjHeFM_e", "review": "1) Summary\nThe manuscript proposes a reversible integration scheme for approximately estimating the gradient of neural ordinary differential equations. These ODEs represent DNNs with continuous rather than discrete values for the number of layers. The solver is theoretically analysed and empirically compared to other solvers.\n\n2) Strengths\n+ The paper is mostly well written.\n+ The reversibility property of the solver leads to a memory footprint that does not depend on integration time.\n+ The model is applied to standard datasets.\n\n3) Concerns\n- The concept of Neural ODE models, their scope and their expected usefulness should be better motivated. It is not obvious which role these models play and what they offer as potential strengths.\n- The integrations scheme seems already known and well established.\n- It does not seem that the paper makes code and data available to the public.\n\n4) Remarks/Questions\n  a) Algorithm 1: It seems that the stepsize h should be initialized upon every step. Otherwise the steps can only get smaller. \n  b) References: capitalization not correct e.g. \"neural information processing systems\", \"ode-net\", \"lennard-jones\"\n  c) What benefits does the neural ODE model have in the context of image classification? What is the intuition behind the \"continuous depth\" idea in this scenario?", "title": "Gradient estimation of neural ODEs with constant memory footprint analysed and compared", "rating": "6: Marginally above acceptance threshold", "confidence": "2: The reviewer is willing to defend the evaluation, but it is quite likely that the reviewer did not understand central parts of the paper"}, "MsiMz9fV1d": {"type": "review", "replyto": "blfSjHeFM_e", "review": "Summary: \nThis paper proposes a new algorithm for solving neural ODEs. Each numerical solver step of the neural ODE is implemented as an invertible neural network via a variant of the asynchronous leafprog integrator. While still computing an accurate gradient, this allows memory savings by discarding intermediate data from the numerical integration steps since it can be reconstructed using the inverse. A theoretical stability analysis is provided. The experimental results show that the algorithm achieves similar performance to previous methods (e.g. ACA) while using less memory. \n\n\nStrengths:\n+ Identifies a nice connection between invertibility and memory efficiency. Beyond neural ODEs, this could enable use of larger models where invertible networks are useful (e.g. normalizing flows)\n+ The theoretical analysis of stability is useful to build intuition\n\n\nConcerns / weaknesses:\n- Most experiments in the paper use damping_factor $= \\eta = 1$. Since theoretically, this is not stable, it would be nice to see if the empirical improvements hold up for $\\eta < 1$, where stable regions do exist\n- The naive method seems too naive. Why are all results from all $m$ evaluations being saved? It is obvious that $m-1$ of these are unnecessary for gradient computation since they don't affect $z(T)$. The related claim about the computation graph being deeper for the naive method also seems incorrect.\n\n\nOther comments:\n- In Algorithm 1, shouldn\u2019t $error_est = \\inf$ be inside the while loop?\n- In Algorithm 4, shouldn\u2019t $a(T)$ be the partial derivative of $L$ wrt $z(T)$ instead of total derivative?\n- In Theorem 3.2, what is $\\sigma$? Should it be $\\sigma_i$?\n- In various locations, notation like $O(N+1)$ is used. Should this just be $O(N)$ since I assume $N$ is at least $\\Omega(1)$?\n- It seems a bit strange that we have to do a local forward and local backward pass in Algorithm 4. Could this be solved by making each layer of f invertible? In the same vein, it seems that the adjoint method needs to do a separate solve of the reverse ODE because of loss of information. If we were to assume invertibility of the forward map, is there a way to modify the adjoint method to exactly retrace the path backwards?", "title": "Neural ODEs + Invertible networks", "rating": "7: Good paper, accept", "confidence": "2: The reviewer is willing to defend the evaluation, but it is quite likely that the reviewer did not understand central parts of the paper"}}}