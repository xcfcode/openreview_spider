{"notes": [{"id": "dzZaIeG9-fW", "original": "OsMOhN-0rem", "number": 2178, "cdate": 1601308239926, "ddate": null, "tcdate": 1601308239926, "tmdate": 1614985638214, "tddate": null, "forum": "dzZaIeG9-fW", "replyto": null, "invitation": "ICLR.cc/2021/Conference/-/Blind_Submission", "content": {"title": "Learning to Infer Run-Time Invariants from Source code", "authorids": ["~Vincent_Josua_Hellendoorn1", "~Premkumar_Devanbu1", "~Alex_Polozov1", "marron@microsoft.com"], "authors": ["Vincent Josua Hellendoorn", "Premkumar Devanbu", "Alex Polozov", "Mark Marron"], "keywords": ["Invariants", "Software Engineering", "Programming Languages"], "abstract": "Source code is notably different from natural language in that it is meant to be executed. Experienced developers infer complex \"invariants\" about run-time state while reading code, which helps them to constrain and predict program behavior. Knowing these invariants can be helpful; yet developers rarely encode these explicitly, so machine-learning methods don't have much aligned data to learn from. We propose an approach that adapts cues within existing if-statements  regarding explicit run-time expectations to generate aligned datasets of code and implicit invariants. We also propose a contrastive loss to inhibit generation of illogical invariants. Our model learns to infer a wide vocabulary of invariants for arbitrary code, which can be used to detect and repair real bugs. This is entirely complementary to established approaches, which either use logical engines that scale poorly, or run-time traces that are expensive to obtain; when present, that data can complement our tool, as we demonstrate in conjunction with Daikon, an existing tool. Our results show that neural models can derive useful representations of run-time behavior directly from source code.", "one-sentence_summary": "A technique for predicting run-time invariants from source code alone", "code_of_ethics": "I acknowledge that I and all co-authors of this work have read and commit to adhering to the ICLR Code of Ethics", "paperhash": "hellendoorn|learning_to_infer_runtime_invariants_from_source_code", "pdf": "/pdf/9a8b40a23dafc62eba2855dbb30fde364d8fa4ef.pdf", "reviewed_version_(pdf)": "https://openreview.net/references/pdf?id=4HTJHCciCm", "_bibtex": "@misc{\nhellendoorn2021learning,\ntitle={Learning to Infer Run-Time Invariants from Source code},\nauthor={Vincent Josua Hellendoorn and Premkumar Devanbu and Alex Polozov and Mark Marron},\nyear={2021},\nurl={https://openreview.net/forum?id=dzZaIeG9-fW}\n}"}, "signatures": ["ICLR.cc/2021/Conference"], "readers": ["everyone"], "nonreaders": [], "writers": ["ICLR.cc/2021/Conference"], "details": {"replyCount": 6, "writable": false, "overwriting": [], "revisions": true, "tags": [], "invitation": {"reply": {"readers": {"values-regex": ".*"}, "writers": {"values": ["ICLR.cc/2021/Conference"]}, "signatures": {"values": ["ICLR.cc/2021/Conference"]}, "content": {"authors": {"values": ["Anonymous"]}, "authorids": {"values-regex": ".*"}, "reviewed_version_(pdf)": {"required": false, "description": "Upload a PDF file that ends with .pdf", "value-regex": ".*"}}}, "signatures": ["ICLR.cc/2021/Conference"], "readers": ["everyone"], "writers": ["ICLR.cc/2021/Conference"], "invitees": ["~", "OpenReview.net/Support"], "tcdate": 1601308008205, "tmdate": 1614984599368, "id": "ICLR.cc/2021/Conference/-/Blind_Submission"}}, "tauthor": "OpenReview.net"}, {"id": "c6nLG4bXYbs", "original": null, "number": 1, "cdate": 1610040523312, "ddate": null, "tcdate": 1610040523312, "tmdate": 1610474132253, "tddate": null, "forum": "dzZaIeG9-fW", "replyto": "dzZaIeG9-fW", "invitation": "ICLR.cc/2021/Conference/Paper2178/-/Decision", "content": {"title": "Final Decision", "decision": "Reject", "comment": "The paper gives a way of constructing a dataset of programs aligned with invariants that the programs satisfy at runtime, and training a model to predict invariants for a given program.\n\nWhile the overall idea behind the paper is reasonable, the execution (in particular, the experimental evaluation) is problematic. As a result, the paper cannot be accepted in its present form. Please see the reviews for more details."}, "signatures": ["ICLR.cc/2021/Conference/Program_Chairs"], "readers": ["everyone"], "nonreaders": [], "writers": ["ICLR.cc/2021/Conference/Program_Chairs"], "details": {"replyCount": 0, "writable": false, "overwriting": [], "revisions": false, "forumContent": {"title": "Learning to Infer Run-Time Invariants from Source code", "authorids": ["~Vincent_Josua_Hellendoorn1", "~Premkumar_Devanbu1", "~Alex_Polozov1", "marron@microsoft.com"], "authors": ["Vincent Josua Hellendoorn", "Premkumar Devanbu", "Alex Polozov", "Mark Marron"], "keywords": ["Invariants", "Software Engineering", "Programming Languages"], "abstract": "Source code is notably different from natural language in that it is meant to be executed. Experienced developers infer complex \"invariants\" about run-time state while reading code, which helps them to constrain and predict program behavior. Knowing these invariants can be helpful; yet developers rarely encode these explicitly, so machine-learning methods don't have much aligned data to learn from. We propose an approach that adapts cues within existing if-statements  regarding explicit run-time expectations to generate aligned datasets of code and implicit invariants. We also propose a contrastive loss to inhibit generation of illogical invariants. Our model learns to infer a wide vocabulary of invariants for arbitrary code, which can be used to detect and repair real bugs. This is entirely complementary to established approaches, which either use logical engines that scale poorly, or run-time traces that are expensive to obtain; when present, that data can complement our tool, as we demonstrate in conjunction with Daikon, an existing tool. Our results show that neural models can derive useful representations of run-time behavior directly from source code.", "one-sentence_summary": "A technique for predicting run-time invariants from source code alone", "code_of_ethics": "I acknowledge that I and all co-authors of this work have read and commit to adhering to the ICLR Code of Ethics", "paperhash": "hellendoorn|learning_to_infer_runtime_invariants_from_source_code", "pdf": "/pdf/9a8b40a23dafc62eba2855dbb30fde364d8fa4ef.pdf", "reviewed_version_(pdf)": "https://openreview.net/references/pdf?id=4HTJHCciCm", "_bibtex": "@misc{\nhellendoorn2021learning,\ntitle={Learning to Infer Run-Time Invariants from Source code},\nauthor={Vincent Josua Hellendoorn and Premkumar Devanbu and Alex Polozov and Mark Marron},\nyear={2021},\nurl={https://openreview.net/forum?id=dzZaIeG9-fW}\n}"}, "tags": [], "invitation": {"reply": {"forum": "dzZaIeG9-fW", "replyto": "dzZaIeG9-fW", "readers": {"values": ["everyone"]}, "writers": {"values": ["ICLR.cc/2021/Conference/Program_Chairs"]}, "signatures": {"values": ["ICLR.cc/2021/Conference/Program_Chairs"]}, "content": {"title": {"value": "Final Decision"}, "decision": {"value-radio": ["Accept (Oral)", "Accept (Spotlight)", "Accept (Poster)", "Reject"]}, "comment": {"value-regex": "[\\S\\s]{0,50000}", "markdown": true}}}, "multiReply": false, "signatures": ["ICLR.cc/2021/Conference"], "readers": ["everyone"], "writers": ["ICLR.cc/2021/Conference"], "invitees": ["ICLR.cc/2021/Conference/Program_Chairs"], "tcdate": 1610040523299, "tmdate": 1610474132238, "id": "ICLR.cc/2021/Conference/Paper2178/-/Decision"}}}, {"id": "af5b2EyUI1y", "original": null, "number": 3, "cdate": 1606242217892, "ddate": null, "tcdate": 1606242217892, "tmdate": 1606242217892, "tddate": null, "forum": "dzZaIeG9-fW", "replyto": "dzZaIeG9-fW", "invitation": "ICLR.cc/2021/Conference/Paper2178/-/Official_Comment", "content": {"title": "General Response", "comment": "We thank the reviewers for their feedback. At this point, we are not asking you to change your scores, but would like to respond to general concerns and clarify some comments here. We will take into account the feedback received while revising this work.\n\nFirst, we underscore that the goal of our approach is quite distinct from virtually all prior work in that it aims to reason about program state at _arbitrary locations_. Several of the responses focused on comparisons to loop invariants, library contracts, and pre/post-conditions. We agree that these are all useful and significant applications, and indeed, technically, our model could be used to predict all of these (and we compared with Daikon in great detail to prove as much). However, it is not our goal to surpass established work in those, comparatively restricted domains, because the unique characteristics of those tasks mean that models designed specifically for them are naturally more useful there. For instance, in the loop invariant case, there is often the possibility of proving the validity of a prediction, which means that models that are designed for those settings can rely on e.g. SMT solvers and iterative/guided generation of invariants. This is clearly a useful (and well-covered) task, and we do not expect to beat established models that can rely on guided search. Yet, by symmetry, those models are not at all as broadly applicable as ours -- we can generate predictions for any given range of code, which has never been possible before.\n\nSecond, while most reviewers recognized the novelty of our approach, there were questions regarding the usefulness of predicting such (guard-like) invariants. This is a reasonable concern considering the breadth and novelty of our objective. We do emphasize that our model is demonstrably capable of detecting and repairing bugs. Some took issue with that evaluation being done in a fairly targeted fashion that assumed some bug localization; to those we note that such a setting is highly typical for evaluating current bug detection/repair work. We also argue, since some reviewers questioned the applicability of if-guards to invariant prediction, that the sheer overlap of our invariants with Daikon\u2019s signals that our predicted statements are hardly biased towards if-guards alone.\n\nFinally, we emphasize the timeliness of this line of work: an increasing number of papers in the last few years have focused on modeling program state as complementary to its syntax. We strongly concur that capturing state directly is of great benefit, and argue that our model\u2019s ability to make general statements about that state can be instrumental in a wide range of downstream applications. As such, our approach may offer much potential in future explorations."}, "signatures": ["ICLR.cc/2021/Conference/Paper2178/Authors"], "readers": ["everyone"], "nonreaders": [], "writers": ["ICLR.cc/2021/Conference", "ICLR.cc/2021/Conference/Paper2178/Authors"], "details": {"replyCount": 0, "writable": false, "overwriting": [], "revisions": false, "forumContent": {"title": "Learning to Infer Run-Time Invariants from Source code", "authorids": ["~Vincent_Josua_Hellendoorn1", "~Premkumar_Devanbu1", "~Alex_Polozov1", "marron@microsoft.com"], "authors": ["Vincent Josua Hellendoorn", "Premkumar Devanbu", "Alex Polozov", "Mark Marron"], "keywords": ["Invariants", "Software Engineering", "Programming Languages"], "abstract": "Source code is notably different from natural language in that it is meant to be executed. Experienced developers infer complex \"invariants\" about run-time state while reading code, which helps them to constrain and predict program behavior. Knowing these invariants can be helpful; yet developers rarely encode these explicitly, so machine-learning methods don't have much aligned data to learn from. We propose an approach that adapts cues within existing if-statements  regarding explicit run-time expectations to generate aligned datasets of code and implicit invariants. We also propose a contrastive loss to inhibit generation of illogical invariants. Our model learns to infer a wide vocabulary of invariants for arbitrary code, which can be used to detect and repair real bugs. This is entirely complementary to established approaches, which either use logical engines that scale poorly, or run-time traces that are expensive to obtain; when present, that data can complement our tool, as we demonstrate in conjunction with Daikon, an existing tool. Our results show that neural models can derive useful representations of run-time behavior directly from source code.", "one-sentence_summary": "A technique for predicting run-time invariants from source code alone", "code_of_ethics": "I acknowledge that I and all co-authors of this work have read and commit to adhering to the ICLR Code of Ethics", "paperhash": "hellendoorn|learning_to_infer_runtime_invariants_from_source_code", "pdf": "/pdf/9a8b40a23dafc62eba2855dbb30fde364d8fa4ef.pdf", "reviewed_version_(pdf)": "https://openreview.net/references/pdf?id=4HTJHCciCm", "_bibtex": "@misc{\nhellendoorn2021learning,\ntitle={Learning to Infer Run-Time Invariants from Source code},\nauthor={Vincent Josua Hellendoorn and Premkumar Devanbu and Alex Polozov and Mark Marron},\nyear={2021},\nurl={https://openreview.net/forum?id=dzZaIeG9-fW}\n}"}, "tags": [], "invitation": {"reply": {"content": {"title": {"order": 0, "value-regex": ".{1,500}", "description": "Brief summary of your comment.", "required": true}, "comment": {"order": 1, "value-regex": "[\\S\\s]{1,5000}", "description": "Your comment or reply (max 5000 characters). Add formatting using Markdown and formulas using LaTeX. For more information see https://openreview.net/faq", "required": true, "markdown": true}}, "forum": "dzZaIeG9-fW", "readers": {"description": "Who your comment will be visible to. If replying to a specific person make sure to add the group they are a member of so that they are able to see your response", "values-dropdown": ["ICLR.cc/2021/Conference/Program_Chairs", "ICLR.cc/2021/Conference/Paper2178/Area_Chairs"], "default": ["ICLR.cc/2021/Conference/Program_Chairs", "ICLR.cc/2021/Conference/Paper2178/Area_Chairs"]}, "writers": {"values-copied": ["ICLR.cc/2021/Conference", "{signatures}"]}, "signatures": {"values-regex": "ICLR.cc/2021/Conference/Paper2178/AnonReviewer[0-9]+|ICLR.cc/2021/Conference/Paper2178/Authors|ICLR.cc/2021/Conference/Paper2178/Area_Chair[0-9]+|ICLR.cc/2021/Conference/Program_Chairs", "description": "How your identity will be displayed."}}, "expdate": 1610649480000, "final": [], "readers": ["everyone"], "nonreaders": [], "invitees": ["ICLR.cc/2021/Conference", "ICLR.cc/2021/Conference/Paper2178/Area_Chairs", "ICLR.cc/2021/Conference/Program_Chairs", "OpenReview.net/Support"], "noninvitees": [], "tcdate": 1601923851346, "tmdate": 1610649509835, "super": "ICLR.cc/2021/Conference/-/Comment", "signatures": ["ICLR.cc/2021/Conference"], "writers": ["ICLR.cc/2021/Conference"], "id": "ICLR.cc/2021/Conference/Paper2178/-/Official_Comment"}}}, {"id": "gU4Epd_Vxg", "original": null, "number": 1, "cdate": 1603820791165, "ddate": null, "tcdate": 1603820791165, "tmdate": 1605024270088, "tddate": null, "forum": "dzZaIeG9-fW", "replyto": "dzZaIeG9-fW", "invitation": "ICLR.cc/2021/Conference/Paper2178/-/Official_Review", "content": {"title": "interesting idea, execution leaves a lot to be desired ", "review": "### Summary ###\nThe paper presents a technique for inference of certain kinds of program invariants directly from the program\u2019s source code. The basic idea is to treat conditional statements as hints for facts about the program state that should hold at a given program point. \n\n\n### Strengths ###\n\n* This is a challenging problem and the paper shows some successful examples. The idea that some useful invariants can be inferred based on local information, while not new, is interesting and can lead to follow up work of practical value.\n\n* The contrastive hinge loss of syntactically close but semantically opposite statements is interesting. \n\n### Weaknesses ###\n\n* The paper falls short on the framing of the invariant inference problem, and on the technical details of what does it mean to infer a meaningful local invariant. Starting from trivialities like the fact that the problem is generally undecidable (and not as stated in Section 2), through the use of incorrect terminology for invariants, guards, pre/post conditions, etc. This just makes the paper hard to follow. \n\n* Fundamentally, beyond simple invariants (array bounds, nullness checks) it is not clear why program invariants would generalize well across different programs. The exception is of course the use of libraries and invariants in library contracts (as learned in [PLDI19a, PLDI19b]). For nullness guards, you should take a look at [https://arxiv.org/pdf/1902.06111.pdf]. I think it would improve the paper if you could focus on a certain kind of invariants, and show that these invariants can in fact generalize across programs. \n\n* As a concrete example, take your own Figure 1. Assuming that these are two different programs, there is no reason to assume that the contract of `calculateTime()` remains the same. Had `calculateTime()` been part of some standard library shared between programs, the case for generalization would have been much stronger. \n\n* There has been so much work on static inference of invariants that it is impossible to list even all the closely related work. Some things that are worth looking into are the work on Scalable static analysis [Scaling], the inference of necessary preconditions [Logozzo], and bug detection that is based on \"belief\" [deviant, belief], which is closely related to your intuition about naturalness and human-written invariants. Also helpful to look at [loopInvariant] and the related work mentioned there. \n\n* Comparison to Daikon. As you correctly point out, Daikon infers likely pre/postconditions. The description of how you compare your invariants to those inferred by Daikon is not clear unless all relevant cases related to (pre)conditions on method parameters. \n\n\n### Questions for Authors ###\n\n* It would be helpful to see more characteristics of the real missing if conditions that you have collected. I am wondering if these are simple conditions of the kind of missing nullness checks or missing array-bound checks. The way in which you have collected these samples is likely to create a bias towards simple missing conditions. How many terms are in these conditions? How many of them are nullness checks? How many are array-bound checks? How many include simple string operations and/or other simple method calls as implied by Table 2? \n\n\n### Improving the Paper ###\n\n1. I liked the idea of removing conditionals to infer likely necessary preconditions. It would help to clarify when what you predict is a guard, a precondition, an invariant, or something else. \n\n2. You are clearly not trying to infer any loop invariants, and it would help clarify that upfront. \n\n\n### References ###\n\n[PLDI19a] Scalable taint specification inference with big code\nhttps://dl.acm.org/doi/10.1145/3314221.3314648\n\n[PLDI19b] Unsupervised learning of API aliasing specifications\nhttps://dl.acm.org/doi/10.1145/3314221.3314640\n\n[Scaling] Scaling static analyses at Facebook\nhttps://dl.acm.org/doi/10.1145/3338112\n\n[Logozzo] Automatic inference of necessary preconditions\nhttps://link.springer.com/chapter/10.1007/978-3-642-35873-9_10\n\n[deviant] Bugs as deviant behavior: a general approach to inferring errors in systems code\nhttps://dl.acm.org/doi/10.1145/502034.502041\n\n[belief] Static error detection using semantic inconsistency inference\nhttps://dl.acm.org/doi/abs/10.1145/1250734.1250784\n\n[loopInvariants] Learning Loop Invariants for Program Verification\nhttp://papers.nips.cc/paper/8001-learning-loop-invariants-forprogram-verification\n\n", "rating": "5: Marginally below acceptance threshold", "confidence": "5: The reviewer is absolutely certain that the evaluation is correct and very familiar with the relevant literature"}, "signatures": ["ICLR.cc/2021/Conference/Paper2178/AnonReviewer4"], "readers": ["everyone"], "nonreaders": [], "writers": ["ICLR.cc/2021/Conference", "ICLR.cc/2021/Conference/Paper2178/AnonReviewer4"], "details": {"replyCount": 0, "writable": false, "overwriting": [], "revisions": false, "forumContent": {"title": "Learning to Infer Run-Time Invariants from Source code", "authorids": ["~Vincent_Josua_Hellendoorn1", "~Premkumar_Devanbu1", "~Alex_Polozov1", "marron@microsoft.com"], "authors": ["Vincent Josua Hellendoorn", "Premkumar Devanbu", "Alex Polozov", "Mark Marron"], "keywords": ["Invariants", "Software Engineering", "Programming Languages"], "abstract": "Source code is notably different from natural language in that it is meant to be executed. Experienced developers infer complex \"invariants\" about run-time state while reading code, which helps them to constrain and predict program behavior. Knowing these invariants can be helpful; yet developers rarely encode these explicitly, so machine-learning methods don't have much aligned data to learn from. We propose an approach that adapts cues within existing if-statements  regarding explicit run-time expectations to generate aligned datasets of code and implicit invariants. We also propose a contrastive loss to inhibit generation of illogical invariants. Our model learns to infer a wide vocabulary of invariants for arbitrary code, which can be used to detect and repair real bugs. This is entirely complementary to established approaches, which either use logical engines that scale poorly, or run-time traces that are expensive to obtain; when present, that data can complement our tool, as we demonstrate in conjunction with Daikon, an existing tool. Our results show that neural models can derive useful representations of run-time behavior directly from source code.", "one-sentence_summary": "A technique for predicting run-time invariants from source code alone", "code_of_ethics": "I acknowledge that I and all co-authors of this work have read and commit to adhering to the ICLR Code of Ethics", "paperhash": "hellendoorn|learning_to_infer_runtime_invariants_from_source_code", "pdf": "/pdf/9a8b40a23dafc62eba2855dbb30fde364d8fa4ef.pdf", "reviewed_version_(pdf)": "https://openreview.net/references/pdf?id=4HTJHCciCm", "_bibtex": "@misc{\nhellendoorn2021learning,\ntitle={Learning to Infer Run-Time Invariants from Source code},\nauthor={Vincent Josua Hellendoorn and Premkumar Devanbu and Alex Polozov and Mark Marron},\nyear={2021},\nurl={https://openreview.net/forum?id=dzZaIeG9-fW}\n}"}, "tags": [], "invitation": {"reply": {"content": {"title": {"order": 1, "value-regex": ".{0,500}", "description": "Brief summary of your review.", "required": true}, "review": {"order": 2, "value-regex": "[\\S\\s]{1,200000}", "description": "Please provide an evaluation of the quality, clarity, originality and significance of this work, including a list of its pros and cons (max 200000 characters). Add formatting using Markdown and formulas using LaTeX. For more information see https://openreview.net/faq . ***Please remember to file the Code-of-Ethics report. Once you submitted the review, a link to the report will be visible in the bottom right corner of your review.***", "required": true, "markdown": true}, "rating": {"order": 3, "value-dropdown": ["10: Top 5% of accepted papers, seminal paper", "9: Top 15% of accepted papers, strong accept", "8: Top 50% of accepted papers, clear accept", "7: Good paper, accept", "6: Marginally above acceptance threshold", "5: Marginally below acceptance threshold", "4: Ok but not good enough - rejection", "3: Clear rejection", "2: Strong rejection", "1: Trivial or wrong"], "required": true}, "confidence": {"order": 4, "value-radio": ["5: The reviewer is absolutely certain that the evaluation is correct and very familiar with the relevant literature", "4: The reviewer is confident but not absolutely certain that the evaluation is correct", "3: The reviewer is fairly confident that the evaluation is correct", "2: The reviewer is willing to defend the evaluation, but it is quite likely that the reviewer did not understand central parts of the paper", "1: The reviewer's evaluation is an educated guess"], "required": true}}, "forum": "dzZaIeG9-fW", "replyto": "dzZaIeG9-fW", "readers": {"description": "Select all user groups that should be able to read this comment.", "values": ["everyone"]}, "nonreaders": {"values": []}, "writers": {"values-copied": ["ICLR.cc/2021/Conference", "{signatures}"], "description": "How your identity will be displayed."}, "signatures": {"values-regex": "ICLR.cc/2021/Conference/Paper2178/AnonReviewer[0-9]+", "description": "How your identity will be displayed."}}, "expdate": 1607428800000, "duedate": 1606752000000, "multiReply": false, "readers": ["everyone"], "tcdate": 1602538102220, "tmdate": 1606915806659, "super": "ICLR.cc/2021/Conference/-/Official_Review", "signatures": ["OpenReview.net"], "writers": ["ICLR.cc/2021/Conference"], "invitees": ["ICLR.cc/2021/Conference/Paper2178/Reviewers", "OpenReview.net/Support"], "id": "ICLR.cc/2021/Conference/Paper2178/-/Official_Review"}}}, {"id": "o0bFk1Jdus-", "original": null, "number": 2, "cdate": 1603875391633, "ddate": null, "tcdate": 1603875391633, "tmdate": 1605024270021, "tddate": null, "forum": "dzZaIeG9-fW", "replyto": "dzZaIeG9-fW", "invitation": "ICLR.cc/2021/Conference/Paper2178/-/Official_Review", "content": {"title": "Learning to Infer Run-Time Invariants from Source code", "review": "Summary: This paper proposes a novel approach for training a Transformer model to predict program invariant. The model is trained using training data that are synthesized from explicit conditional checks in functions and is used to predict invariants of unguarded blocks in similar functions.     \n\nStrength\n1. The paper addresses the important and challenging problem of program invariant generation from static code in a scalable way. \n2. Real-world \u201cmissing if-guard\u201d bugs are detected using the proposed model.\n\nWeakness\n1. The idea of synthesizing training data by automatically converting explicitly guarded code to its implicitly guarded counterpart is interesting. However, the effectiveness of the trained model to infer program invariants in a general way is not clear from the experimental results. The evaluation with real-world bugs focuses on \u201cmissing if-guard\u201d bugs. The difficulty of detecting this bug cannot be understood as there is no accuracy results from an existing tool (for example, Daikon) in detecting this real-world \n2. Although a comparative analysis with Daikon is presented, the presented approach focuses on a narrower class of invariants compared to Daikon. Moreover, Daikon relies on execution traces. A comparison with an existing ML based approach using static code (e.g., [1]) would provide more interesting insights about the model\u2019s accuracy. \n3. A contrastive hinge loss is introduced to address the \u201csyntactically close\u201d but \u201csemantically opposite\u201d cases. However, from Figure-4, it seems the performance of the model is not impacted in a significant way by the loss function.\n\n[1] P. Garg, D. Neider, P. Madhusudan, and D. Roth. Learning Invariants using Decision Trees and Implication Counterexamples.\n\nQuestion to author:\nPlease address and clarify the cons above.\n", "rating": "5: Marginally below acceptance threshold", "confidence": "3: The reviewer is fairly confident that the evaluation is correct"}, "signatures": ["ICLR.cc/2021/Conference/Paper2178/AnonReviewer2"], "readers": ["everyone"], "nonreaders": [], "writers": ["ICLR.cc/2021/Conference", "ICLR.cc/2021/Conference/Paper2178/AnonReviewer2"], "details": {"replyCount": 0, "writable": false, "overwriting": [], "revisions": false, "forumContent": {"title": "Learning to Infer Run-Time Invariants from Source code", "authorids": ["~Vincent_Josua_Hellendoorn1", "~Premkumar_Devanbu1", "~Alex_Polozov1", "marron@microsoft.com"], "authors": ["Vincent Josua Hellendoorn", "Premkumar Devanbu", "Alex Polozov", "Mark Marron"], "keywords": ["Invariants", "Software Engineering", "Programming Languages"], "abstract": "Source code is notably different from natural language in that it is meant to be executed. Experienced developers infer complex \"invariants\" about run-time state while reading code, which helps them to constrain and predict program behavior. Knowing these invariants can be helpful; yet developers rarely encode these explicitly, so machine-learning methods don't have much aligned data to learn from. We propose an approach that adapts cues within existing if-statements  regarding explicit run-time expectations to generate aligned datasets of code and implicit invariants. We also propose a contrastive loss to inhibit generation of illogical invariants. Our model learns to infer a wide vocabulary of invariants for arbitrary code, which can be used to detect and repair real bugs. This is entirely complementary to established approaches, which either use logical engines that scale poorly, or run-time traces that are expensive to obtain; when present, that data can complement our tool, as we demonstrate in conjunction with Daikon, an existing tool. Our results show that neural models can derive useful representations of run-time behavior directly from source code.", "one-sentence_summary": "A technique for predicting run-time invariants from source code alone", "code_of_ethics": "I acknowledge that I and all co-authors of this work have read and commit to adhering to the ICLR Code of Ethics", "paperhash": "hellendoorn|learning_to_infer_runtime_invariants_from_source_code", "pdf": "/pdf/9a8b40a23dafc62eba2855dbb30fde364d8fa4ef.pdf", "reviewed_version_(pdf)": "https://openreview.net/references/pdf?id=4HTJHCciCm", "_bibtex": "@misc{\nhellendoorn2021learning,\ntitle={Learning to Infer Run-Time Invariants from Source code},\nauthor={Vincent Josua Hellendoorn and Premkumar Devanbu and Alex Polozov and Mark Marron},\nyear={2021},\nurl={https://openreview.net/forum?id=dzZaIeG9-fW}\n}"}, "tags": [], "invitation": {"reply": {"content": {"title": {"order": 1, "value-regex": ".{0,500}", "description": "Brief summary of your review.", "required": true}, "review": {"order": 2, "value-regex": "[\\S\\s]{1,200000}", "description": "Please provide an evaluation of the quality, clarity, originality and significance of this work, including a list of its pros and cons (max 200000 characters). Add formatting using Markdown and formulas using LaTeX. For more information see https://openreview.net/faq . ***Please remember to file the Code-of-Ethics report. Once you submitted the review, a link to the report will be visible in the bottom right corner of your review.***", "required": true, "markdown": true}, "rating": {"order": 3, "value-dropdown": ["10: Top 5% of accepted papers, seminal paper", "9: Top 15% of accepted papers, strong accept", "8: Top 50% of accepted papers, clear accept", "7: Good paper, accept", "6: Marginally above acceptance threshold", "5: Marginally below acceptance threshold", "4: Ok but not good enough - rejection", "3: Clear rejection", "2: Strong rejection", "1: Trivial or wrong"], "required": true}, "confidence": {"order": 4, "value-radio": ["5: The reviewer is absolutely certain that the evaluation is correct and very familiar with the relevant literature", "4: The reviewer is confident but not absolutely certain that the evaluation is correct", "3: The reviewer is fairly confident that the evaluation is correct", "2: The reviewer is willing to defend the evaluation, but it is quite likely that the reviewer did not understand central parts of the paper", "1: The reviewer's evaluation is an educated guess"], "required": true}}, "forum": "dzZaIeG9-fW", "replyto": "dzZaIeG9-fW", "readers": {"description": "Select all user groups that should be able to read this comment.", "values": ["everyone"]}, "nonreaders": {"values": []}, "writers": {"values-copied": ["ICLR.cc/2021/Conference", "{signatures}"], "description": "How your identity will be displayed."}, "signatures": {"values-regex": "ICLR.cc/2021/Conference/Paper2178/AnonReviewer[0-9]+", "description": "How your identity will be displayed."}}, "expdate": 1607428800000, "duedate": 1606752000000, "multiReply": false, "readers": ["everyone"], "tcdate": 1602538102220, "tmdate": 1606915806659, "super": "ICLR.cc/2021/Conference/-/Official_Review", "signatures": ["OpenReview.net"], "writers": ["ICLR.cc/2021/Conference"], "invitees": ["ICLR.cc/2021/Conference/Paper2178/Reviewers", "OpenReview.net/Support"], "id": "ICLR.cc/2021/Conference/Paper2178/-/Official_Review"}}}, {"id": "w9OcVw1PQR", "original": null, "number": 3, "cdate": 1603925561861, "ddate": null, "tcdate": 1603925561861, "tmdate": 1605024269959, "tddate": null, "forum": "dzZaIeG9-fW", "replyto": "dzZaIeG9-fW", "invitation": "ICLR.cc/2021/Conference/Paper2178/-/Official_Review", "content": {"title": "A new application of machine learning for invariant generation", "review": "The paper proposes to discover likely invariants for code by observing snippets that check for the given conditions and assuming these conditions encode invariants for the code executing before and after the condition check was checked to hold (respectively not hold for negated invariant). This is a novel idea that uses code with correct if conditions to guess the invariants for code that has the conditions missing.\n\nMy main criticism for the paper is that it does not give a compelling reason why one would want to apply this technique. While this is a smart way to obtain the invariants, the paper does not give too much intuition why it could be useful in practice. Even on the examples in the paper, the machine learning algorithm probably learns invariants from identifier names and not from the semantics of  the code around.\n\nThe authors can relate the work to a large corpus of learning invariants for functions based on things like usages of functions, e.g. like done in [1] or [2] and the techniques there find actual bugs in code. For example, if the invariant is non-nullness of x, this may be because x comes from a function that sometimes returns null or because it comes from a function that does not accept null. If I would want to do for example bugfinding, I would want to know contradicting invariants coming from the two functions.\n\nIn terms of execution, the paper is well written and the techniques look state-of-the-art from a machine learning perspective (although there are no baselines given). However, the experiments are insufficient for showing usefulness of the idea. With Daikon overlap in the 70% range and precision also in the same range, it is not clear that the tool gives any new valid invariants on top of Daikon. In terms of bugfinding, the results are also inconclusive that any bugs can be found. If I would put the tool to test 100 methods, where normally less than 10 of them are buggy, I can expect 20 false positives.\n\n\n\nMinor:\ntheorem proofers -> theorem provers\nFigure 5 a talks about overlap, but axis says precision.\n\n[1] Ted Kremenek, Paul Twohey, Godmar Back, Andrew Y. Ng, Dawson R. Engler:\nFrom Uncertainty to Belief: Inferring the Specification Within. OSDI 2006\n[2] Insu Yun, Changwoo Min, Xujie Si, Yeongjin Jang, Taesoo Kim, Mayur Naik: APISan: Sanitizing API Usages through Semantic Cross-Checking\n", "rating": "5: Marginally below acceptance threshold", "confidence": "4: The reviewer is confident but not absolutely certain that the evaluation is correct"}, "signatures": ["ICLR.cc/2021/Conference/Paper2178/AnonReviewer1"], "readers": ["everyone"], "nonreaders": [], "writers": ["ICLR.cc/2021/Conference", "ICLR.cc/2021/Conference/Paper2178/AnonReviewer1"], "details": {"replyCount": 0, "writable": false, "overwriting": [], "revisions": false, "forumContent": {"title": "Learning to Infer Run-Time Invariants from Source code", "authorids": ["~Vincent_Josua_Hellendoorn1", "~Premkumar_Devanbu1", "~Alex_Polozov1", "marron@microsoft.com"], "authors": ["Vincent Josua Hellendoorn", "Premkumar Devanbu", "Alex Polozov", "Mark Marron"], "keywords": ["Invariants", "Software Engineering", "Programming Languages"], "abstract": "Source code is notably different from natural language in that it is meant to be executed. Experienced developers infer complex \"invariants\" about run-time state while reading code, which helps them to constrain and predict program behavior. Knowing these invariants can be helpful; yet developers rarely encode these explicitly, so machine-learning methods don't have much aligned data to learn from. We propose an approach that adapts cues within existing if-statements  regarding explicit run-time expectations to generate aligned datasets of code and implicit invariants. We also propose a contrastive loss to inhibit generation of illogical invariants. Our model learns to infer a wide vocabulary of invariants for arbitrary code, which can be used to detect and repair real bugs. This is entirely complementary to established approaches, which either use logical engines that scale poorly, or run-time traces that are expensive to obtain; when present, that data can complement our tool, as we demonstrate in conjunction with Daikon, an existing tool. Our results show that neural models can derive useful representations of run-time behavior directly from source code.", "one-sentence_summary": "A technique for predicting run-time invariants from source code alone", "code_of_ethics": "I acknowledge that I and all co-authors of this work have read and commit to adhering to the ICLR Code of Ethics", "paperhash": "hellendoorn|learning_to_infer_runtime_invariants_from_source_code", "pdf": "/pdf/9a8b40a23dafc62eba2855dbb30fde364d8fa4ef.pdf", "reviewed_version_(pdf)": "https://openreview.net/references/pdf?id=4HTJHCciCm", "_bibtex": "@misc{\nhellendoorn2021learning,\ntitle={Learning to Infer Run-Time Invariants from Source code},\nauthor={Vincent Josua Hellendoorn and Premkumar Devanbu and Alex Polozov and Mark Marron},\nyear={2021},\nurl={https://openreview.net/forum?id=dzZaIeG9-fW}\n}"}, "tags": [], "invitation": {"reply": {"content": {"title": {"order": 1, "value-regex": ".{0,500}", "description": "Brief summary of your review.", "required": true}, "review": {"order": 2, "value-regex": "[\\S\\s]{1,200000}", "description": "Please provide an evaluation of the quality, clarity, originality and significance of this work, including a list of its pros and cons (max 200000 characters). Add formatting using Markdown and formulas using LaTeX. For more information see https://openreview.net/faq . ***Please remember to file the Code-of-Ethics report. Once you submitted the review, a link to the report will be visible in the bottom right corner of your review.***", "required": true, "markdown": true}, "rating": {"order": 3, "value-dropdown": ["10: Top 5% of accepted papers, seminal paper", "9: Top 15% of accepted papers, strong accept", "8: Top 50% of accepted papers, clear accept", "7: Good paper, accept", "6: Marginally above acceptance threshold", "5: Marginally below acceptance threshold", "4: Ok but not good enough - rejection", "3: Clear rejection", "2: Strong rejection", "1: Trivial or wrong"], "required": true}, "confidence": {"order": 4, "value-radio": ["5: The reviewer is absolutely certain that the evaluation is correct and very familiar with the relevant literature", "4: The reviewer is confident but not absolutely certain that the evaluation is correct", "3: The reviewer is fairly confident that the evaluation is correct", "2: The reviewer is willing to defend the evaluation, but it is quite likely that the reviewer did not understand central parts of the paper", "1: The reviewer's evaluation is an educated guess"], "required": true}}, "forum": "dzZaIeG9-fW", "replyto": "dzZaIeG9-fW", "readers": {"description": "Select all user groups that should be able to read this comment.", "values": ["everyone"]}, "nonreaders": {"values": []}, "writers": {"values-copied": ["ICLR.cc/2021/Conference", "{signatures}"], "description": "How your identity will be displayed."}, "signatures": {"values-regex": "ICLR.cc/2021/Conference/Paper2178/AnonReviewer[0-9]+", "description": "How your identity will be displayed."}}, "expdate": 1607428800000, "duedate": 1606752000000, "multiReply": false, "readers": ["everyone"], "tcdate": 1602538102220, "tmdate": 1606915806659, "super": "ICLR.cc/2021/Conference/-/Official_Review", "signatures": ["OpenReview.net"], "writers": ["ICLR.cc/2021/Conference"], "invitees": ["ICLR.cc/2021/Conference/Paper2178/Reviewers", "OpenReview.net/Support"], "id": "ICLR.cc/2021/Conference/Paper2178/-/Official_Review"}}}, {"id": "KotmMUQKhyV", "original": null, "number": 4, "cdate": 1604384877923, "ddate": null, "tcdate": 1604384877923, "tmdate": 1605024269885, "tddate": null, "forum": "dzZaIeG9-fW", "replyto": "dzZaIeG9-fW", "invitation": "ICLR.cc/2021/Conference/Paper2178/-/Official_Review", "content": {"title": "Ok paper but lacks evaluation ", "review": "The paper presents a method for statically learning code invariants from source code using a variant of transformers.\n\nStrengths\n----\n- The paper demonstrates that on the synthetic dataset the proposed approach can infer many invariants. \n\nWeaknesses\n----\n- The evaluation with a synthetic dataset seems very weak. \u201cIf\u201d checks are not good proxies for useful invariants as in most programs there are many if checks that are simply unreachable or redundant. In practice,  not all invariants are useful for the downstream tasks (code fixing, bug finding, etc.) mentioned by the authors. Without a more direct evaluation, it is very hard to tell how useful the learned invariants actually are for these tasks. The paper will be significantly stronger if the authors can evaluate their tool against existing loop invariant inference datasets with ground truth data like those used in Si et al. (NeuRIPS 2018). \n\n- The transformer-based model seems to be directly reused from Hallendoorn et al. (ICLR 2020). Thus the contribution in terms of model design is limited. \n\n- The authors also did not cite/compare against the current state-of-the-art loop invariant learning work: CLN2INV: Learning Loop Invariants with Continuous Logic Networks. Ryan et al. ICLR 2020", "rating": "3: Clear rejection", "confidence": "4: The reviewer is confident but not absolutely certain that the evaluation is correct"}, "signatures": ["ICLR.cc/2021/Conference/Paper2178/AnonReviewer3"], "readers": ["everyone"], "nonreaders": [], "writers": ["ICLR.cc/2021/Conference", "ICLR.cc/2021/Conference/Paper2178/AnonReviewer3"], "details": {"replyCount": 0, "writable": false, "overwriting": [], "revisions": false, "forumContent": {"title": "Learning to Infer Run-Time Invariants from Source code", "authorids": ["~Vincent_Josua_Hellendoorn1", "~Premkumar_Devanbu1", "~Alex_Polozov1", "marron@microsoft.com"], "authors": ["Vincent Josua Hellendoorn", "Premkumar Devanbu", "Alex Polozov", "Mark Marron"], "keywords": ["Invariants", "Software Engineering", "Programming Languages"], "abstract": "Source code is notably different from natural language in that it is meant to be executed. Experienced developers infer complex \"invariants\" about run-time state while reading code, which helps them to constrain and predict program behavior. Knowing these invariants can be helpful; yet developers rarely encode these explicitly, so machine-learning methods don't have much aligned data to learn from. We propose an approach that adapts cues within existing if-statements  regarding explicit run-time expectations to generate aligned datasets of code and implicit invariants. We also propose a contrastive loss to inhibit generation of illogical invariants. Our model learns to infer a wide vocabulary of invariants for arbitrary code, which can be used to detect and repair real bugs. This is entirely complementary to established approaches, which either use logical engines that scale poorly, or run-time traces that are expensive to obtain; when present, that data can complement our tool, as we demonstrate in conjunction with Daikon, an existing tool. Our results show that neural models can derive useful representations of run-time behavior directly from source code.", "one-sentence_summary": "A technique for predicting run-time invariants from source code alone", "code_of_ethics": "I acknowledge that I and all co-authors of this work have read and commit to adhering to the ICLR Code of Ethics", "paperhash": "hellendoorn|learning_to_infer_runtime_invariants_from_source_code", "pdf": "/pdf/9a8b40a23dafc62eba2855dbb30fde364d8fa4ef.pdf", "reviewed_version_(pdf)": "https://openreview.net/references/pdf?id=4HTJHCciCm", "_bibtex": "@misc{\nhellendoorn2021learning,\ntitle={Learning to Infer Run-Time Invariants from Source code},\nauthor={Vincent Josua Hellendoorn and Premkumar Devanbu and Alex Polozov and Mark Marron},\nyear={2021},\nurl={https://openreview.net/forum?id=dzZaIeG9-fW}\n}"}, "tags": [], "invitation": {"reply": {"content": {"title": {"order": 1, "value-regex": ".{0,500}", "description": "Brief summary of your review.", "required": true}, "review": {"order": 2, "value-regex": "[\\S\\s]{1,200000}", "description": "Please provide an evaluation of the quality, clarity, originality and significance of this work, including a list of its pros and cons (max 200000 characters). Add formatting using Markdown and formulas using LaTeX. For more information see https://openreview.net/faq . ***Please remember to file the Code-of-Ethics report. Once you submitted the review, a link to the report will be visible in the bottom right corner of your review.***", "required": true, "markdown": true}, "rating": {"order": 3, "value-dropdown": ["10: Top 5% of accepted papers, seminal paper", "9: Top 15% of accepted papers, strong accept", "8: Top 50% of accepted papers, clear accept", "7: Good paper, accept", "6: Marginally above acceptance threshold", "5: Marginally below acceptance threshold", "4: Ok but not good enough - rejection", "3: Clear rejection", "2: Strong rejection", "1: Trivial or wrong"], "required": true}, "confidence": {"order": 4, "value-radio": ["5: The reviewer is absolutely certain that the evaluation is correct and very familiar with the relevant literature", "4: The reviewer is confident but not absolutely certain that the evaluation is correct", "3: The reviewer is fairly confident that the evaluation is correct", "2: The reviewer is willing to defend the evaluation, but it is quite likely that the reviewer did not understand central parts of the paper", "1: The reviewer's evaluation is an educated guess"], "required": true}}, "forum": "dzZaIeG9-fW", "replyto": "dzZaIeG9-fW", "readers": {"description": "Select all user groups that should be able to read this comment.", "values": ["everyone"]}, "nonreaders": {"values": []}, "writers": {"values-copied": ["ICLR.cc/2021/Conference", "{signatures}"], "description": "How your identity will be displayed."}, "signatures": {"values-regex": "ICLR.cc/2021/Conference/Paper2178/AnonReviewer[0-9]+", "description": "How your identity will be displayed."}}, "expdate": 1607428800000, "duedate": 1606752000000, "multiReply": false, "readers": ["everyone"], "tcdate": 1602538102220, "tmdate": 1606915806659, "super": "ICLR.cc/2021/Conference/-/Official_Review", "signatures": ["OpenReview.net"], "writers": ["ICLR.cc/2021/Conference"], "invitees": ["ICLR.cc/2021/Conference/Paper2178/Reviewers", "OpenReview.net/Support"], "id": "ICLR.cc/2021/Conference/Paper2178/-/Official_Review"}}}], "count": 7}